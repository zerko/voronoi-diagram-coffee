// Generated by CoffeeScript 1.6.2
(function() {
  var Voronoi;

  Voronoi = (function() {
    function Voronoi() {
      this.sites = null;
      this.edges = null;
      this.cells = null;
      this.queue = new VQueue;
      this.width = 0;
      this.height = 0;
      this.root = null;
      this.ly = 0;
      this.lasty = 0;
      this.fp = null;
    }

    Voronoi.prototype.compute = function(sites, width, height) {
      var cell, e, edge, ev, site, _i, _j, _len, _len1, _ref, _ref1, _results;

      this.sites = sites;
      this.width = width;
      this.height = height;
      if (this.sites.length < 2) {
        return [];
      }
      this.root = null;
      this.edges = [];
      this.cells = [];
      this.queue.clear();
      _ref = this.sites;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        site = _ref[_i];
        ev = new VEvent(site, true);
        cell = new VPolygon;
        site.cell = cell;
        this.queue.enqueue(ev);
        this.cells.push(cell);
      }
      while (!this.queue.isEmpty()) {
        e = this.queue.dequeue();
        this.ly = e.point.y;
        if (e.pe) {
          this.insertParabola(e.point);
        } else {
          this.removeParabola(e);
        }
      }
      this.finishEdge(this.root);
      _ref1 = this.edges;
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        edge = _ref1[_j];
        if (edge.neighbour) {
          _results.push(edge.start = edge.neighbour.end);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Voronoi.prototype.insertParabola = function(p) {
      var el, er, p0, p1, p2, par, s, start;

      if (!this.root) {
        this.root = new VParabola(p);
        this.fp = p;
        return;
      }
      if (this.root.isLeaf && (this.root.site.y - p.y) < 0.01) {
        this.root.isLeaf = false;
        this.root.setLeft(new VParabola(this.fp));
        this.root.setRight(new VParabola(p));
        s = new Point((p.x + this.fp.x) / 2, this.height);
        if (p.x > this.fp.x) {
          this.root.edge = new VEdge(s, this.fp, p);
        } else {
          this.root.edge = new VEdge(s, p, this.fp);
        }
        this.edges.push(this.root.edge);
        return;
      }
      par = this.getParabolaByX(p.x);
      if (par.cEvent) {
        this.queue.remove(par.cEvent);
        par.cEvent = null;
      }
      start = new Point(p.x, this.getY(par.site, p.x));
      el = new VEdge(start, par.site, p);
      er = new VEdge(start, p, par.site);
      el.neighbour = er;
      this.edges.push(el);
      par.edge = er;
      par.isLeaf = false;
      p0 = new VParabola(par.site);
      p1 = new VParabola(p);
      p2 = new VParabola(par.site);
      par.setRight(p2);
      par.setLeft(new VParabola);
      par.left.edge = el;
      par.left.setLeft(p0);
      par.left.setRight(p1);
      this.checkCircle(p0);
      return this.checkCircle(p2);
    };

    Voronoi.prototype.removeParabola = function(e) {
      var gparent, higher, p, p0, p1, p2, par, xl, xr;

      p1 = e.arch;
      xl = this.getLeftParent(p1);
      xr = this.getRightParent(p1);
      p0 = this.getLeftChild(xl);
      p2 = this.getRightChild(xr);
      if (p0.cEvent) {
        this.queue.remove(p0.cEvent);
        p0.cEvent = null;
      }
      if (p2.cEvent) {
        this.queue.remove(p2.cEvent);
        p2.cEvent = null;
      }
      p = new Point(e.point.x, this.getY(p1.site, e.point.x));
      if (p0.site.cell.last === p1.site.cell.first) {
        p1.site.cell.addLeft(p);
      } else {
        p1.site.cell.addRight(p);
      }
      p0.site.cell.addRight(p);
      p2.site.cell.addLeft(p);
      this.lasty = e.point.y;
      xl.edge.end = p;
      xr.edge.end = p;
      par = p1;
      while (par !== this.root) {
        par = par.parent;
        if (par === xl) {
          higher = xl;
        }
        if (par === xr) {
          higher = xr;
        }
      }
      higher.edge = new VEdge(p, p0.site, p2.site);
      this.edges.push(higher.edge);
      gparent = p1.parent.parent;
      if (p1.parent.left === p1) {
        if (gparent.left === p1.parent) {
          gparent.setLeft(p1.parent.right);
        } else {
          p1.parent.parent.setRight(p1.parent.right);
        }
      } else {
        if (gparent.left === p1.parent) {
          gparent.setLeft(p1.parent.left);
        } else {
          gparent.setRight(p1.parent.left);
        }
      }
      this.checkCircle(p0);
      return this.checkCircle(p2);
    };

    Voronoi.prototype.finishEdge = function(n) {
      var mx;

      if (n.edge.direction.x > 0.0) {
        mx = Math.max(this.width, n.edge.start.x + 10);
      } else {
        mx = Math.min(0.0, n.edge.start.x - 10);
      }
      n.edge.end = new Point(mx, n.edge.f * mx + n.edge.g);
      if (!n.left.isLeaf) {
        this.finishEdge(n.left);
      }
      if (!n.right.isLeaf) {
        return this.finishEdge(n.right);
      }
    };

    Voronoi.prototype.getXOfEdge = function(par, y) {
      var a, a1, a2, b, b1, b2, c, c1, c2, disc, dp, left, p, r, right, ry, x1, x2;

      left = this.getLeftChild(par);
      right = this.getRightChild(par);
      p = left.site;
      r = right.site;
      dp = 2 * (p.y - y);
      a1 = 1 / dp;
      b1 = -2 * p.x / dp;
      c1 = y + dp * 0.25 + p.x * p.x / dp;
      dp = 2 * (r.y - y);
      a2 = 1 / dp;
      b2 = -2 * r.x / dp;
      c2 = y + dp * 0.25 + r.x * r.x / dp;
      a = a1 - a2;
      b = b1 - b2;
      c = c1 - c2;
      disc = b * b - 4 * a * c;
      x1 = (-b + Math.sqrt(disc)) / (2 * a);
      x2 = (-b - Math.sqrt(disc)) / (2 * a);
      if (p.y < r.y) {
        ry = Math.max(x1, x2);
      } else {
        ry = Math.min(x1, x2);
      }
      return ry;
    };

    Voronoi.prototype.getParabolaByX = function(xx) {
      var par, x;

      par = this.root;
      x = 0;
      while (!par.isLeaf) {
        x = this.getXOfEdge(par, this.ly);
        if (x > xx) {
          par = par.left;
        } else {
          par = par.right;
        }
      }
      return par;
    };

    Voronoi.prototype.getY = function(p, x) {
      var b1, c1, dp;

      dp = 2 * (p.y - this.ly);
      b1 = -2 * p.x / dp;
      c1 = this.ly + dp / 4 + p.x * p.x / dp;
      return x * x / dp + b1 * x + c1;
    };

    Voronoi.prototype.checkCircle = function(b) {
      var a, c, d, e, lp, rp, s;

      lp = this.getLeftParent(b);
      rp = this.getRightParent(b);
      a = this.getLeftChild(lp);
      c = this.getRightChild(rp);
      if (!a || !c || (a.site === c.site)) {
        return;
      }
      s = this.getEdgeIntersection(lp.edge, rp.edge);
      if (!s) {
        return;
      }
      d = Point.prototype.distance(a.site, s);
      if ((s.y - d) >= this.ly) {
        return;
      }
      e = new VEvent(new Point(s.x, s.y - d), false);
      b.cEvent = e;
      e.arch = b;
      return this.queue.enqueue(e);
    };

    Voronoi.prototype.getEdgeIntersection = function(a, b) {
      var I, wd;

      I = this.getLineIntersection(a.start, a.B, b.start, b.B);
      wd = (I.x - a.start.x) * a.direction.x < 0 || (I.y - a.start.y) * a.direction.y < 0 || (I.x - b.start.x) * b.direction.x < 0 || (I.y - b.start.y) * b.direction.y < 0;
      if (wd) {
        return null;
      }
      return I;
    };

    Voronoi.prototype.getLeftParent = function(n) {
      var pLast, par;

      par = n.parent;
      pLast = n;
      while (par.left === pLast) {
        if (!par.parent) {
          return null;
        }
        pLast = par;
        par = par.parent;
      }
      return par;
    };

    Voronoi.prototype.getRightParent = function(n) {
      var pLast, par;

      par = n.parent;
      pLast = n;
      while (par.right === pLast) {
        if (!par.parent) {
          return null;
        }
        pLast = par;
        par = par.parent;
      }
      return par;
    };

    Voronoi.prototype.getLeftChild = function(n) {
      var par;

      if (!n) {
        return null;
      }
      par = n.left;
      while (!par.isLeaf) {
        par = par.right;
      }
      return par;
    };

    Voronoi.prototype.getRightChild = function(n) {
      var par;

      if (!n) {
        return null;
      }
      par = n.right;
      while (!par.isLeaf) {
        par = par.left;
      }
      return par;
    };

    Voronoi.prototype.getLineIntersection = function(a1, a2, b1, b2) {
      var A, B, I, dax, day, dbx, dby, den;

      dax = a1.x - a2.x;
      dbx = b1.x - b2.x;
      day = a1.y - a2.y;
      dby = b1.y - b2.y;
      den = dax * dby - day * dbx;
      if (den === 0) {
        return null;
      }
      A = a1.x * a2.y - a1.y * a2.x;
      B = b1.x * b2.y - b1.y * b2.x;
      I = new Point(0, 0);
      I.x = (A * dbx - dax * B) / den;
      I.y = (A * dby - day * B) / den;
      return I;
    };

    return Voronoi;

  })();

}).call(this);
